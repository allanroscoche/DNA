\chapter{Sequenciamento Genético}
O sequenciamento genético tem como objetivo descobrir a sequência completa de DNA do genoma de um organismo.
%Para a realização do sequenciamento processos químicos são utilizados para a identificação dos nucleotídios da sequência.
%Agressive Assembly of pyrosequencing reads with mates
Pequenas strings de bases nucléicas geradas pelo sequenciador chamadas leituras.
Os sequenciadores são máquinas que automatizam os processos químicos utilizados para a identificação dos nucleotídios das leituras.
Além das diferenças no funcionamento interno, cada sequenciador difere na quantidade e na qualidade das leituras produzidas.

As leituras possuem um tamanho determinado pela tecnologia utilizada no sequenciador. Várias leituras são necessárias para cobrir todo o genoma de um organismo.
%Todo método de sequenciamento passa pela fase de clonagem, nesta fase um organismo vetor é utilizado para se obter as leituras, por causa disso, o tamanho das leituras é limitado pela capacidade do organismo vetor.

%Quando o sequenciamento é realizado sequencialmente, isto é, cada sequência é obtida uma após a outra, o método é chamado sequenciamento direcinado, e quando várias sequências são produzidas paralelamente o método de sequenciamento é chamado aleatório ou shotgun.


\section{Método Shotgun de sequenciamento}
O método shotgun de sequenciamento consiste em obter várias sequências aleatórias do genoma paralelamente.
Assim várias leituras são obtidas de partes aleatórias do genoma e para se obter o genome a ser sequenciado é necessário ser realizada a montagem dessas leituras. A montagem é um processo computacional onde as sequências são comparadas entre si e atraves dessas comparações é gerado uma aproximação do genoma sequênciado. Essa aproximação é formada por um conjunto de strings chamados contigs e a ausencia de strings chamados gaps.

\section{Next Generation Sequencers - NGS}
%Evaluation of next generation sequencing platforms for population targeted sequencing studies
Alguns dos NGSs, incluindo Roche 454, Illumina GA, e ABI SOLiD, são capazes de gerar de três a quatro ordens de magnitude mais leituras
e são consideravelmente mais baratas que o método Sanger na plataforma ABI 3730xL.
% [2-4].
%High-quality draft assemblies of mammalian genomes from massively parallel sequence data
A princípio, isso deveria tornar possível a diminuição drástica do custo de gerar a montagem de genomas. Na prática, entretanto, isso tem sido difícil porque as novas tecnologias produzem leituras de até 100 bases de tamanho( comparando com $>$ 700 bases da tecnologia Sanger). Esse leituras curtas são também menos confiáveis. Por ambos os motivos, esses dados são mais difíceis de montar numa sequencia contínua e conectada.

Devido a essas características, para o sequenciamento 'de novo' utilizando NGS's é utilizada uma grande cobertura do genoma, entre 30x e 600x para compensar esses problemas.

%B. Ewing, P. Green, Base-calling of automated sequencer traces using phred.
Todos esses novos sequenciadores produzem além da letra que representa a molécula de DNA, o valor numérico representando a qualidade para cada base.
%All sequencers produce observations of the target DNA molecule in the form of reads: sequences of single-letter base calls plus a numeric quality value (QV) for each base call.

%Assembly Algoritms for next-generation data
%Although QVs offer extra information, their use generally increases a program's CPU and RAM requirements. Only some of the NGS assembly software exploits QVs.
Apesar desse número ser uma informação extra, isso normalmente aumenta os requerimentos de CPU e RAM dos programas. Apenas alguns montadores NGS exploram essa informação.

\section{ABI Solid}
Uma das diferenças da plataforma SOLiD dentre os outros sequenciadores é a codificação de duas bases em que cada ponto representa o encontro de duas bases, logo, cada base é verificada duas vezes.
Devido a essa característica os dados não são gravados como bases mas sim em 'color space', onde cada cor representa duas bases adjacentes.
Uma desvantagem na utilização do 'color space' é que a conversão para bases nucléicas é que os erros são amplificados durante a tradução, por isso, a manipulação dessas sequências são realizadas nesse formato.


\chapter{Montagem das leituras}


O problema da montagem é, através das leituras obtidas pelo sequenciador, obter o genoma sendo sequenciado.
As naiores dificuldades na montagem está nos erros encontrados nas leituras, a detecção regiões repetitivas e perceber a falta de cobertura para alguma região do genoma.

Segundo \cite{Algorithms1995} o problema de montagem pode ser modelado como o problema de reconstrução de string.


\section{Montagem Tradicional}

A montagem tradicional consiste em achar um alinhamento entre as leituras e através de um grafo de sobreposição realizar a montagem.

Para se encontrar o melhor alinhamento local entre duas string é utilizado o algoritmo de smith-waterman \cite{}.

No grafo sobreposições cada nó representa uma leitura e cada aresta representa uma sobreposição entre duas leituras.
Um peso é atribuído a cara aresta de acordo com a qualidade do alinhamento.
Para realizarmos a montagem devemos achar um caminho halmitoniano nesse grafo, o que é um problema NP-completo.

\section{Montagem no NGS}
Contudo devido a grande quantidade de leituras que um NGS produz é necessária uma outra abordagem para a comparação das leituras. Isso é realizado dividindo as leituras em pedaços menores e realizando uma comparação direta desse pedaços.
Esses pedaços são chamados kmers e são utilizados para a criação do grafo de bruijn.

%Esses pedaços são chamados de k-mers e são utilizados nas duas estratégias a seguir:
%\subsection{read expansion}
%No read expansion, após dividirmos as leituras em tamanhos menores é utilizada uma estrutura de dados para indexar esses pedaçõs e realizando buscas nessa estrutura procuramos por outros pedaços que possam ser alinhados e, desse modo, expandimos uma leitura adicionando novas bases encontradas nas buscas. O montador SSAKE utiliza essa estratégia.
%\subsection{grafo de bruijn}
No grafo de bruijn cada kmer é um nó e cada aresta é uma relação de igualdade de $k-1$ letras.
Para uma representação mais simples é utilizada uma versão condensada do grafo como visto na \ref{bruijn}.
Em $A$ é gerado o grafo de bruijn da leitura e em $B$ o grafo de convertido para a forma condensada.

\begin{figure}[ht] % [especificador de posição]:exemplos [htbp] - h:aqui, t:topo, b:baixo, p:página especial, !: desconsiderar parâmetros internos
\begin{center}
\includegraphics[scale=.5]{./figuras/bruijn2.eps} %Opções: width (largura em pt ou cm ou vezes se não houver unidade de medida), height (altura em pt, cm ou vezes se não houver unidade de medid), angle (rotação em graus), scale (escala em vezes 0.5= 50%,1.5=150%, etc )
\end{center}
 
\caption[Grafo de Bruijn]{Exemplo de um grafo de bruijn gerado por uma sequência de bases}
\label{bruijn}
\end{figure}


Após a contrução do de bruijn, é gerado um supercaminho euleriano nesse grafo, e com isso realizamos a montagem das leituras.
Apesar desse algoritmo também utilizar um grafo como na montagme tradicional, o problema do supercaminho euleriano possui um algoritmo de tempo polinomial. Tornando possível a sua utilização por montadores NGS.

\section{Correção de Erros}
A diferenciação principal dos montadores NGS está nos algoritmos utilizados para o tratamento de erros do sequenciamento.
Aa correção de erros pode ser feito em duas fases: uma após a construção do grafo, como é o caso do algoritmo Pebble do velvet, ou antes da indexação dos kmers.

\chapter{Pipeline Solid}

Esse capítulo descreve o funcionamento do pipeline para o sequenciamento 'de novo' utilizando a plataforma SOLiD.
Devido ao sequenciador solid gerar os seus dados em 'color space', o montador deve ser capaz de manipular os dados nesse formato, e com isso o pipeline se faz necessário para a montagem \cite{Biosystems}.

%\section{pipeline}
Podemos observar na figura ~\ref{pipeline} o pipeline denovo.

\begin{figure}[ht] % [especificador de posição]:exemplos [htbp] - h:aqui, t:topo, b:baixo, p:página especial, !: desconsiderar parâmetros internos
\begin{center}
\includegraphics[scale=.4]{./figuras/pipeline.eps} %Opções: width (largura em pt ou cm ou vezes se não houver unidade de medida), height (altura em pt, cm ou vezes se não houver unidade de medida), angle (rotação em graus), scale (escala em vezes 0.5= 50%,1.5=150%, etc )
\end{center}
 
\caption[Pipeline SOLiD denovo (aparece na Lista de
  Figuras)]{Pipeline Utilizado pela plataforma SOLiD}
\label{pipeline}
\end{figure}

O pipeline constituído por uma série de programas que preparam os dados para um montador capaz de realizar a montagem em 'color space' e além disso realizam outros processos para melhorar a qualidade da montagem.
Neste capítulo não vamos mostrar todos os softwares, apenas aqueles que foram necessários ao estudo.


\section{saet}
O SOLiD Accuracy Enhancement Tool(SAET) é usado para a correção de erros pré-montagem.
O programa gera todos os kmers presente nas leituras e seleciona aqueles que possuem uma cobertura mínima.
Infelizmente o código-fonte é fechado e todo o conhecimento sobre o programa foi obtido por sua documentação.

\section{preprocessor}
Neste estágio, as leituras são convertidas do formato 'color space' para o formato 'pseudobases'.
Nesse novo formato a primeira base é retirada e cada cor é convertido para uma letra correspondente.
As letras utilizadas nesse formato não representam as bases nucléicas das leituras, apenas as cores do 'colorspace', a transformação para as bases é realizada apenas na fase final do pipeline.

\section{Velvet}
O Velvet é um conjunto de algoritmos que utilizam grafos de Bruijn para a realização da montagem das leituras, eliminando erros e resolvendo repetições \cite{Zerbino2008}.


O software é dividido em dois executáveis: o velveth e o velvetg.

%No velvet, cada nó do grafo é ligado ao seu complemento genético formando assim um bloco.

\subsection{velveth}
No velveth ocorre a fase de criação e indexação dos kmers, o arquivo de leituras é carregado na memória e os kmers são gerados.
A estrutura de dados utilizada para o armazenamento dos kmers é uma tabela hash onde cada elemento é uma árvore splay de kmers.
Essa tabela então é gravada no arquivo Roadmap.

%Na versão paralela do velveth utilizando o OpenMP a escrita no arquivo Roadmap depende do escalonamento do processador, tornando o programa velvet não determinístico.

\subsection{velvetg}

No grafo de bruijn utilizado pelo velvet, cada nó no grafo é uma série de kmers sobrepostos. Kmers adjacentes sobrepõe-se k-1 nucleotídios e a informação remanescente de cada kmer é sua última base. Esse conjunto de bases é chamado sequência. Cada nó no grafo é anexado ao nó reflexo que representa o seu complemento reverso das bases nucléicas dos kmers. A união desses dois nós é chamado bloco e pode ser observado na fig ~\ref{bruijn-velvet}.

\begin{figure}[ht] % [especificador de posição]:exemplos [htbp] - h:aqui, t:topo, b:baixo, p:página especial, !: desconsiderar parâmetros internos
\begin{center}
\includegraphics[scale=.5]{./figuras/bruijn_velvet.eps} %Opções: width (largura em pt ou cm ou vezes se não houver unidade de medida), height (altura em pt, cm ou vezes se não houver unidade de medid), angle (rotação em graus), scale (escala em vezes 0.5= 50%,1.5=150%, etc )
\end{center}
 
\caption[Nós do grafo de bruijn utilizado no velvet]{Exemplo de nós do grafo de bruijn gerado pelo velvet}
\label{bruijn-velvet}
\end{figure}

O primeiro grafo gerado pelo velvetg utiliza o arquivo Roadmap e uma estrutura de dados eficiente em memória.
Esta estrutura é utilizada apenas para a contrução, uma correção de erros simples e uma simplificação do grafo onde nós são concatenados.
Após essa fase, outra estrutura de dados é utilizada para que os algoritmos de correção de erro possam manipular mais facilmente o grafo.

A remoção de erros é realizada pelo algoritmo Tour Bus.
O tratamento das repetições é realizado por dois algoritmos: o Tour Bus e o Pebble \cite{Zerbino2009}
Depois que a primeira estrutura ou scaffold é gerada pelo algoritmo pebble, uma busca heurística em profundidade é realizada e a estrutura final é gerada.
Com isso o arquivo \emph{contigs.fa} é gerado onde estão todos os contigs da montagem.

\section{ASiD}

A programa Assembly Assistant for SOLiD System tem duas funcionalidades: preencher os gaps nos scaffolds e converter as leituras de 'color-space' para 'base-space'.
A primeira está habilitada apenas quando as leituras estão pareadas.
Nas leituras pareadas, cada leitura está conectada a outra leitura por uma distância estimada de bases da outra.
Para isso ele cria um arquivo com uma coleção de leituras que são as mais prováveis para realizar a união de dois contigs, com esse arquivo ele utiliza o velvet para realizar uma nova montagem. Se o novo contig gerado possui uma sobreposição entre os dois contigs originais, esses são concatenados.




%\chapter{Experimentos VelvetH}
