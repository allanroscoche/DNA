\chapter{Sequenciamento Genético}

Este capítulo descreve brevemente o sequenciamento genético e os
\emph{Next Generation Sequencers}(NGS).
Será detalhado o funcionamento do sequenciador SOLiD4 e sua codificação
exclusiva de dados.


%-----------------------
%Sequenciamento Genético: O que é? Como é realizado? Por que estudar?
%NGS: O que é?
%ABI SOLiD4:
%Sequenciamento por ligação
%ColorSpace:
%Qualidade das leituras
%Pontuação de qualidade PHRED

%----------------------

O sequenciamento genético é utilizado para determinar a sequência de
genes individuais, cromossomos ou genomas completos. O foco desse
trabalho está no sequênciamento 'de novo' de genomas completos. A
expressão \emph{de novo} é utilizada para expressar o sequenciamento de
genomas que ainda desconhecidos, ou seja, onde nenhum sequenciamento
já tenha sido realizado.
%Para a realização do sequenciamento processos químicos são utilizados
%para a identificação dos nucleotídios da sequência.
%Agressive Assembly of pyrosequencing reads with mates

O ácido desoxirribonucleico(ADN, em ingles: DNA) é um longo polímero
formada por unidades repetidas chamadas nucleotídeos \ref .
%Alberts, Bruce; Alexander Johnson, Julian Lewis, Kazuo, Martin Raff,
%Keith Roberts, and Peter Walters. Molecular Biology of the Cell; Fourth
%Edition. Nova Iorque e Londres: Garland Science, 2002. ISBN 0-8153-3218-1

Os nucleotídios presentes no DNA são: citosina, adenina, guanina e
timina, e vão ser representados respectivamente pelas letras: $C$, $A$,
$G$ e $T$.

Para a identificação dos nucleotídios são utilizados sequenciadores, máquinas que automatizam os
processos químicos utilizados para a identificação das bases nitrogenadas.



Cada sequenciador difere na quantidade e na qualidade das leituras
produzidas devido aos processos químicos aplicados.


%As leituras possuem um tamanho máximo determinado pela tecnologia
%utilizada no sequenciador. Devido a essa limitação de tamanho, várias leituras são necessárias para cobrir todo o genoma de um organismo.
%Todo método de sequenciamento passa pela fase de clonagem, nesta fase um organismo vetor é utilizado para se obter as leituras, por causa disso, o tamanho das leituras é limitado pela capacidade do organismo vetor.

%Quando o sequenciamento é realizado sequencialmente, isto é, cada sequência é obtida uma após a outra, o método é chamado sequenciamento direcinado, e quando várias sequências são produzidas paralelamente o método de sequenciamento é chamado aleatório ou shotgun.


\section{Método Shotgun de sequenciamento}
O método shotgun de sequenciamento consiste em obter várias sequências aleatórias do genoma paralelamente.
Desse modo para obter o genoma a ser sequenciado é necessário a montagem dessas leituras. A montagem é um processo computacional onde as sequências são comparadas entre si e atraves dessas comparações é gerado uma aproximação do genoma sequênciado. Essa aproximação é formada por um conjunto de strings chamados contigs e a ausencia de strings chamados gaps.

\section{Next Generation Sequencers - NGS}
%Evaluation of next generation sequencing platforms for population targeted sequencing studies
Alguns dos NGSs, incluindo Roche 454, Illumina GA, e ABI SOLiD, são capazes de gerar de três a quatro ordens de magnitude mais leituras
e são consideravelmente mais baratas que o método Sanger na plataforma ABI 3730xL.
% [2-4].
%High-quality draft assemblies of mammalian genomes from massively parallel sequence data
A princípio, isso deveria tornar possível a diminuição drástica do custo de gerar a montagem de genomas. Na prática, entretanto, isso tem sido difícil porque as novas tecnologias produzem leituras de até 100 bases de tamanho( comparando com $>$ 700 bases da tecnologia Sanger). Esse leituras curtas são também menos confiáveis. Por ambos os motivos, esses dados são mais difíceis de montar numa sequencia contínua e conectada.
Devido a essas características, para o sequenciamento 'de novo' utilizando NGS's é utilizada uma grande cobertura do genoma, entre 30x e 600x para compensar esses problemas.

%B. Ewing, P. Green, Base-calling of automated sequencer traces using phred.
Todos esses novos sequenciadores produzem além da letra que representa a molécula de DNA, o valor numérico representando a qualidade para cada base.
%All sequencers produce observations of the target DNA molecule in the form of reads: sequences of single-letter base calls plus a numeric quality value (QV) for each base call.

%Assembly Algoritms for next-generation data
%Although QVs offer extra information, their use generally increases a program's CPU and RAM requirements. Only some of the NGS assembly software exploits QVs.
Apesar desse número ser uma informação extra, isso normalmente aumenta os requerimentos de CPU e RAM dos programas. Apenas alguns montadores NGS exploram essa informação.

\section{ABI Solid}
Uma das diferenças da plataforma SOLiD dentre os outros sequenciadores é a codificação de duas bases em que cada ponto representa o encontro de duas bases, logo, cada base é verificada duas vezes.
Devido a essa característica os dados não são gravados como bases mas sim em 'color space', onde cada cor representa duas bases adjacentes.
Uma desvantagem na utilização do 'color space' é que a conversão para
bases nucléicas é que os erros são amplificados durante a tradução, por
isso, a manipulação dessas sequências são realizadas no formato 'color space'.


\chapter{Montagem das leituras}


O problema da montagem é, através das leituras obtidas pelo sequenciador, obter o genoma sendo sequenciado.
As maiores dificuldades na montagem estão: nos erros encontrados nas leituras, a detecção regiões repetitivas e perceber a falta de cobertura para alguma região do genoma.

Alguns montadores utilzam um grafo de sobreposições para realizar a
montagem.
O nós do grafo representas as leituras do sequenciador e as arestas
representam um alinhamento local entre duas leituras.
Um peso é atribuído a cara aresta de acordo com a qualidade do alinhamento.
A montagem é realizada procurando um caminho halmitoniano nesse grafo,
contudo, esse é um problema NP-completo.

\section{Montagem utilizando um grafo de Bruijn}
Contudo devido a grande quantidade de leituras que um NGS(Next
Generation Sequencer) produz é necessária uma outra abordagem para a
montagem.
Para evitar a comparação todos-contra-todos entre as leituras, elas são
divididas em pedaços menores e é realizada uma comparação direta desse pedaços.
Esses pedaços são chamados kmers e são utilizados para a criação do grafo de bruijn.

%Esses pedaços são chamados de k-mers e são utilizados nas duas estratégias a seguir:
%\subsection{read expansion}
%No read expansion, após dividirmos as leituras em tamanhos menores é utilizada uma estrutura de dados para indexar esses pedaçõs e realizando buscas nessa estrutura procuramos por outros pedaços que possam ser alinhados e, desse modo, expandimos uma leitura adicionando novas bases encontradas nas buscas. O montador SSAKE utiliza essa estratégia.
%\subsection{grafo de bruijn}
No grafo de bruijn cada kmer é um nó e cada aresta é uma relação de igualdade de $k-1$ letras.
Para uma representação mais simples é utilizada uma versão condensada do grafo como visto na \ref{bruijn}.
Em $A$ é gerado o grafo de bruijn da leitura e em $B$ o grafo de convertido para a forma condensada.

\begin{figure}[ht] % [especificador de posição]:exemplos [htbp] - h:aqui, t:topo, b:baixo, p:página especial, !: desconsiderar parâmetros internos
\begin{center}
\includegraphics[scale=.5]{./figuras/bruijn2.eps} %Opções: width (largura em pt ou cm ou vezes se não houver unidade de medida), height (altura em pt, cm ou vezes se não houver unidade de medid), angle (rotação em graus), scale (escala em vezes 0.5= 50%,1.5=150%, etc )
\end{center}

\caption[Grafo de Bruijn]{Exemplo de um grafo de bruijn gerado por uma sequência de bases}
\label{bruijn}
\end{figure}

Após a contrução do grafo de bruijn, um supercaminho euleriano é
encontrado nesse grafo, e com isso realizamos a montagem das leituras.
A principal vantagem de se utilizar o grafo de bruijn deve-se ao fato do
problema do supercaminho euleriano possuir um algoritmo de tempo
polinomial.
Tornando viável a sua utilização por montadores NGS.

\section{Correção de Erros}
A diferenciação principal entre os montadores dos NGS está nos algoritmos utilizados para o tratamento de erros do sequenciamento.
A correção de erros pode ser feito antes da realização da montagem ou
após a contrução do grafo. A principal característica da remoção de
erros pré-montagem é a utilização do arquivo de qualidade como forma de
eliminar ou corrigir leituras problemáticas. A fig \ref{erro_leitura} demonstra uma
leitura com erros. As posições onde a base não pode ser determinada está
representada com pontos. Abaixo da leitura está a qualidade de cada
posição onde é possível observar a qualidade $-1$ nas posições onde há pontos.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.8]{./figuras/erro_leitura.eps}
\end{center}

\caption[Leitura com erro]{Exemplo de leitura com erros}
\label{erro_leitura}
\end{figure}

Erros de sequenciamento também podem ser detectados após a contrução do
grafo.

\chapter{Pipeline Solid}

Esse capítulo descreve o funcionamento do pipeline para o sequenciamento 'de novo' utilizando a plataforma SOLiD.
Devido ao sequenciador solid gerar os seus dados em 'color space', o montador deve ser capaz de manipular os dados nesse formato, e com isso o pipeline se faz necessário para a montagem \cite{Biosystems}.

%\section{pipeline}
Podemos observar na figura ~\ref{pipeline} o pipeline denovo.

\begin{figure}[ht] % [especificador de posição]:exemplos [htbp] - h:aqui, t:topo, b:baixo, p:página especial, !: desconsiderar parâmetros internos
\begin{center}
\includegraphics[scale=.4]{./figuras/pipeline.eps} %Opções: width (largura em pt ou cm ou vezes se não houver unidade de medida), height (altura em pt, cm ou vezes se não houver unidade de medida), angle (rotação em graus), scale (escala em vezes 0.5= 50%,1.5=150%, etc )
\end{center}

\caption[Pipeline SOLiD denovo (aparece na Lista de
  Figuras)]{Pipeline Utilizado pela plataforma SOLiD}
\label{pipeline}
\end{figure}

O pipeline constituído por uma série de programas que preparam os dados para um montador capaz de realizar a montagem em 'color space' e além disso realizam outros processos para melhorar a qualidade da montagem.
Neste capítulo não vamos mostrar todos os softwares, apenas aqueles que foram necessários ao estudo.


\section{saet}
O SOLiD Accuracy Enhancement Tool(SAET) é usado para a correção de erros pré-montagem.
O programa gera todos os kmers presente nas leituras e seleciona aqueles que possuem uma cobertura mínima.
Infelizmente o código-fonte é fechado e não há a possibilidade de um
estudo mais profundo.

\section{preprocessor}
Neste estágio, as leituras são convertidas do formato 'color space' para o formato 'pseudobases'.
Nesse novo formato a primeira base é retirada e cada cor é convertido para uma letra correspondente.
As letras utilizadas nesse formato não representam as bases nucléicas das leituras, apenas as cores do 'colorspace', a transformação para as bases é realizada apenas na fase final do pipeline.

\section{Velvet}
O Velvet é um conjunto de algoritmos que utilizam grafos de Bruijn para a realização da montagem das leituras, eliminando erros e resolvendo repetições \cite{Zerbino2008}.
O software é dividido em dois executáveis: o velveth e o velvetg.

%No velvet, cada nó do grafo é ligado ao seu complemento genético formando assim um bloco.

%\subsection{velveth}
No velveth ocorre a fase de criação dos kmers, o arquivo de leituras é
carregado na memória e os kmers são gerados. Uma tabela hash é utilizada
para o armazenamento dos kmers para então o arquivo de saída Roadmap ser gerado.
%A estrutura de dados utilizada para o armazenamento dos kmers é uma tabela hash onde cada elemento é uma árvore splay de kmers.

%Na versão paralela do velveth utilizando o OpenMP a escrita no arquivo Roadmap depende do escalonamento do processador, tornando o programa velvet não determinístico.

%\subsection{velvetg}
O velvetg constrói um grafo de bruijn a partir do arquivo gerado pelo
velveth. Cada nó no grafo é uma série de kmers sobrepostos.
 Kmers adjacentes sobrepõe-se k-1 nucleotídios e a informação
 remanescente de cada kmer é sua última base.
 Esse conjunto de bases é chamado sequência.
 Cada nó no grafo é anexado ao nó reflexo que representa o seu
 complemento reverso das bases nucléicas dos kmers.
 A união desses dois nós é chamado bloco e pode ser observado na fig ~\ref{bruijn-velvet}.

\begin{figure}[ht] % [especificador de posição]:exemplos [htbp] - h:aqui, t:topo, b:baixo, p:página especial, !: desconsiderar parâmetros internos
\begin{center}
\includegraphics[scale=.5]{./figuras/bruijn_velvet.eps} %Opções: width (largura em pt ou cm ou vezes se não houver unidade de medida), height (altura em pt, cm ou vezes se não houver unidade de medid), angle (rotação em graus), scale (escala em vezes 0.5= 50%,1.5=150%, etc )
\end{center}

\caption[Nós do grafo de bruijn utilizado no velvet]{Exemplo de nós do grafo de bruijn gerado pelo velvet}
\label{bruijn-velvet}
\end{figure}

O primeiro grafo gerado pelo velvetg utiliza o arquivo Roadmap e uma estrutura de dados eficiente em memória.
Esta estrutura é utilizada apenas para a contrução, uma correção de erros simples e uma simplificação do grafo onde nós são concatenados.
Após essa fase, outra estrutura de dados é utilizada para que os algoritmos de correção de erro possam manipular mais facilmente o grafo.

A remoção de erros é realizada pelo algoritmo Tour Bus.
O tratamento das repetições é realizado por dois algoritmos: o Tour Bus e o Pebble \cite{Zerbino2009}
Depois que a primeira estrutura ou scaffold é gerada pelo algoritmo pebble, uma busca heurística em profundidade é realizada e a estrutura final é gerada.
Com isso o arquivo \emph{contigs.fa} é gerado onde estão todos os contigs da montagem.

\section{ASiD}

A programa Assembly Assistant for SOLiD System tem duas funcionalidades: preencher os gaps nos scaffolds e converter as leituras de 'color-space' para 'base-space'.
A primeira está habilitada apenas quando as leituras estão pareadas.
Nas leituras pareadas, cada leitura está conectada a outra leitura por uma distância estimada de bases da outra.
Para isso ele cria um arquivo com uma coleção de leituras que são as mais prováveis para realizar a união de dois contigs, com esse arquivo ele utiliza o velvet para realizar uma nova montagem. Se o novo contig gerado possui uma sobreposição entre os dois contigs originais, esses são concatenados.



%\chapter{Experimentos}

%Umas das primeiras decisões ao se utilizar o pipeline é o
%tamanho $k$ a utilizar.


\chapter{Proposta}

Neste capítulo duas propostas são apresentadas.
A primeira tem como objetivo diminuir a necessidade de recursos computacionais como também explorar novas heurísticas para remoção de erros pré-montagem.
A segunda proposta veio da necessidade em descobrir qual é o tamanho $k$ ideal para realizar uma montagem. Uma estrutura de dados é utilizada para realizar uma busca por esse melhor tamanho.


\section{Pipeline Solid}
Uma das grandes dificuldades para lidar com os arquivos gerados pelos
NGSs é o tamanho dos dados gerados. Arquivos de texto com mais de 10Gb
normalmente são utilizados e copiados a cada estágio do pipeline.

Para diminuir o tempo gasto em disco, um novo pipeline mostrado na fig
\ref{pipeline_presolid} é proposto. As três primeiras fases são
realizadas por um único programa que manipula as leituras em memória
para cada tarefa.

\begin{figure}[ht] % [especificador de posição]:exemplos [htbp] - h:aqui, t:topo, b:baixo, p:página especial, !: desconsiderar parâmetros internos
\begin{center}
\includegraphics[scale=.5]{./figuras/pipeline_presolid.eps} %Opções: width (largura em pt ou cm ou vezes se não houver unidade de medida), height (altura em pt, cm ou vezes se não houver unidade de medid), angle (rotação em graus), scale (escala em vezes 0.5= 50%,1.5=150%, etc )
\end{center}

\caption[Nós do grafo de bruijn utilizado no velvet]{Exemplo de nós do grafo de bruijn gerado pelo velvet}
\label{pipeline_presolid}
\end{figure}

Com a retirada do Saet do pipeline, uma estratégia para a redução de
erros é proposto baseados nas qualidades de cada base.

%\subsection{Pontuação por posição}
A estratégia utiliza um valor minimo de qualidade como
referência. A qualidade de cada base é comparada com o valor mínimo a partir da primeira até a última.
A pontuação de cada leitura será a posição até a primeira qualidade abaixo do limite seja encontrada, ou o tamanho da leitura caso todas as qualidades estejam acima do limite.
Dessa maneira leituras com pontuações maiores podem gerar mais kmers confiáveis, pois devido ao sequenciamento por ligação, se uma base não é confiável no meio da leitura, todas as bases subsequêntes também não são.
Após a pontuação de cada leitura, ela é ignorada se não obter uma pontuação máxima.

Essa eliminação de leituras também é utilizada como uma forma de diminuir a cobertura das leituras, fase que é realizada após a identificação de erros.

Após isso as leituras são convertidos para pseudobases e escritas em disco para a utilização do velvet.

%---------
\section{K-mer virtual}

Como foi visto no \ref{}, uma das dificuldades ao se utilizar o grafo de bruijn é escolher o tamanho dos kmers.
Um método muito simples para achar o melhor tamanho é realizar várias montagens variando o $k$ dentro de um intervalo e achar a melhor montagem.
 É proposta uma nova estrutura de dados em que o tamanho $k$ está relacionado com a organização da estrutura, e deste modo, variar o tamanho do $k$ sem que seja necessário executar todo o pipeline. 




\begin{figure}[ht] % [especificador de posição]:exemplos [htbp] - h:aqui, t:topo, b:baixo, p:página especial, !: desconsiderar parâmetros internos
\begin{center}
\includegraphics[scale=.5]{./figuras/pipeline_prevelvet.eps} %Opções: width (largura em pt ou cm ou vezes se não houver unidade de medida), height (altura em pt, cm ou vezes se não houver unidade de medid), angle (rotação em graus), scale (escala em vezes 0.5= 50%,1.5=150%, etc )
\end{center}

\caption[Nós do grafo de bruijn utilizado no velvet]{Exemplo de nós do grafo de bruijn gerado pelo velvet}
\label{pipeline_prevelvet}
\end{figure}


\chapter{Cronograma}
