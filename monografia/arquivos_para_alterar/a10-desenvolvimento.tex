
\chapter{O problema da montagem}

O problema da montagem surgiu com o desenvolvimento do sequênciamento
genético, onde novas estratégias foram adotadas e com elas, processos
mecânicos e químicos puderam ser substituídos por soluções computacionais.
Para entender o surgimento do problema, é necessário também a
compreensão de como sequenciamento é realizado, e quais são suas limitações.

\section{Estratégias de sequenciamento}

Sequenciar um genoma não é uma tarefa simples e envolve
múltiplos processos: clonagem do DNA, mapeamento físico,
subclonagem, sequenciamento e análise da informação. E em muitos desses
processos a quantidade de informação que pode ser gerada de cada vez é
limitada. Com isso, o sequenciamento de um genoma é realizado lendo um
pedaço de cada vez. Os pedaços lidos são utilizados para descobrir regiões
genéticas maiores, como por exemplo os genes.

As estratégias utilizadas acabem se classificado em duas categorias: a direcionada e aleatória.

\subsubsection{Estratégia direcionada}
Essa estratégia permite a análise direta e sequencial de um grande
fragmento de DNA do início ao fim. A técnica consiste em a partir de uma
leitura inicial, ir caminhando pela sequência genética lendo um pedaço
adjacente por vez até chegar ao final do código sequenciado. Para a
realização dessa estratégia, a próxima leitura começará no final da
anterior, utilizando a sobreposição entre as duas para certificar de que
se trata da continuação da leitura anterior.


Podemos observar na figura ~\ref{fig01} as sobreposições das leituras e sentido do sequenciamento.

\begin{figure}[ht] % [especificador de posição]:exemplos [htbp] - h:aqui, t:topo, b:baixo, p:página especial, !: desconsiderar parâmetros internos
\begin{center}
\includegraphics[scale=.9]{./figuras/direcionado.eps} %Opções: width (largura em pt ou cm ou vezes se não houver unidade de medida), height (altura em pt, cm ou vezes se não houver unidade de medida), angle (rotação em graus), scale (escala em vezes 0.5= 50%,1.5=150%, etc )
\end{center}
 
\caption[Estratégia direcionada (aparece na Lista de
  Figuras)]{Sequenciamento utilizando a estratégia direcionada}
\label{fig01}
\end{figure}

Para se certificar que a próxima leitura iniciará no final da leitura
anterior, é preparado em laboratório o material que sequenciará apenas o
código genético iniciado com a sobreposição.
Como essa estratégia envolve uma série de sequenciamentos e pausas para
a preparação do material, ela é mais lenta do que a estratégia aleatória.



\subsubsection{Estratégia aleatória}

A estratégia aleatória ou shotgun consiste na realização de várias
leituras aleatórias do material a ser sequenciado. Quando a região lida
por dois fragmentos possiu uma intersecção, uma sobreposição entre eles
é gerado. Com uma amostragem o suficiente, o material genético pode ser
reconstruído realizando a montagem dos fragmentos de acordo com suas
sobreposições %\ref{}.

A figura ~\ref{fig02} demonstra uma montagem dos fragmentos.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.9]{./figuras/shotgun.eps}
\end{center}
\caption[Estratégia aleatória (aparece na Lista de
  Figuras)]{Sequenciamento utilizando a estratégia aleatória}
\label{fig02}
\end{figure}

A estratégia aleatória possui a vantagem de sequenciar mais rápido o
material genético, pois cada leitura pode ser gerada em paralelo com as
utras, não havendo a necessidade de uma pausa para cada sequenciamento.
Contudo a utilização dessa estratégia surge o problema computacional
da montagem dos fragmentos sequenciados que vamos definir a seguir.

Uma sequência \emph{s} de DNA será uma string sobre o alfabeto
de quatro letras \{a,c,g,t\}, cada letra corresponde ao primeiro caractere
do nome químico de cada nucleotídio e o código genético a ser sequenciado a
superstring \emph{L}. O problema da montagem será alinhar as
sequências \emph{s} para obter a superstring \emph{L} utilizando as sobreposições entre as leituras.

Um problema parecido com o da montagem é o \emph{menor superstring comum} onde dado uma coleção de
strings queremos encontrar a menor string \emph{S}, chamada superstring, tal que cada membro da
coleção é uma substring de \emph{S}. Duas diferenças no conjunto de entrada muda a complexidade do problema,
são elas a probabilidade de erro das bases e o não conhecimento da orientação das leituras.

Cada string da coleção de entrada pode possuir erros como: a falta de um caractere, a adição de um
caractere não existente ou a troca de um caractere por outro. Essas diferenças são denominadas respectivamente:
subtração, adição e substituição.

Outra dificuldade é o não conhecimento da orientação da leitura. O complemento de uma leitura é dada uma
string \emph{ACCTGA} tomamos o seu inverso \emph{AGTCCA} e trocamos cada caractere pelo seu complemento:
a=t, c=g, g=c, t=a. Ficando assim \emph{TCAGGT}.

Segundo \cite{1}:

Definição. O problema de reconstrução da sequência de DNA (RECONSTRUCT) é,
dado uma coleção \emph{F} de sequências fragmentadas e uma taxa de erro
0 < \emph{e} < 1, achar a menor sequência \emph{S} tal que para todo fragmento
\emph{A} E  \emph{F} existe uma substring \emph{B} de \emph{S} tal que:

min(d(A,B),d(!A,B)) <= \emph{e} |\emph{A}|.


\section{Organização do conjunto de leituras}



Primeiramente vamos nos concentrar em definir o cenário do caso ideal, onde
o problema da montagem consiste em construir o genoma de um organismo
através da leituras obtida pelos sequenciadores. Os sequenciadores
produzem apenas pedaços do genoma e queremos através desses pedaços
conseguir descobrir o genoma completo do organismo sequenciado.

Contudo isso normalmente não é possível, através dos dados produzidos pelos
sequenciadores conseguimos chegar a uma aproximação do genoma do
organismo. Essa aproximação consiste em construir pedaços maiores do
genoma utilizando as leituras obtidas. Um conjunto de leituras é
organizado de tal forma que reflete um pedaço contínuo do genoma, esse conjunto de leituras nomeia-se contig.

Uma abordagem que utilizaremos para o problema é abstrair o significado biológico da montagem e
concentrar apenas no problema genérico.

Considerando um alfabeto que possui apenas as letras A,C,G,T.
O genoma do organismo consiste numa string sobre esse alfabeto. As
leituras são substrings do genoma. E através dessas
leituras queremos gerar os contigs que é um conjunto de leituras
alinhadas de tal maneira que formam uma sequência contínua pertencente ao genoma.

Uma analogia para o problema da montagem é considerarmos as leituras
como peças de um quebra cabeça que queremos montar. Devemos encaixar
todas essas peças afim de achar a solução do problema. A principal
diferença está no fato de poder não existir uma solução perfeita, ou
seja, pode ser que tenham leituras faltando ou sobrando e dessa forma
o quebra-cabeça nunca estará completo.

Para conseguimos montar o nosso quebra-cabeças devemos descobrir como
as peças se encaixam, para isso vamos realizar o emparalhamento par
a par de cada sequência para definir quanto cada leitura é parecida com
a outra encontrando a maior subsequencia comum entre os dois.

%Longest common subsequence problem


\section{Alinhamento de sequências}

O alinhamento consiste em comparar duas ou mais sequências
procurando por uma série ou padrões de letras que estão na mesma ordem
entre nas sequências.
Podemos ``desenhar'' um alinhamento escrevendo uma sequência em cada
linha, e após isso, as letras idênticas são colocadas na mesma coluna,
indicando através de uma linha entre elas. As letras diferentes podem
ser colocadas na mesma coluna ou deixar um espaço caso necessário.

Existem dois tipos de alinhamentos: o global e o local. Exemplificados
pela figura.

No alinhamento global de sequências queremos que o maior número possível
de letras em cada leitura sejam alinhados até o final. Sequências que
são bem similares e de tamanhos parecidos são bons candidatos para esse
tipo de alinhamento. No alinhamento local regiões muito similares entre
as leituras são alinhadas.



\section{Alinhamento de sequências utilizando palavras}

Quando não estamos procurando apenas a solução ótima para o alinhamento
entre sequências podemos utilizar um algoritmo mais rápido para achar
uma solução aproximada ou satisfatória para a comparação.

Um método para comparar rapidamente leituras é realizar uma busca por
 palavras ou k-tuplas dentro de uma leitura. De uma maneira similiar
utilizado pelo programa FASTA, vamos procurar por palavras iguais dentro
das leituras, certificando assim que K bases contínuas são iguais.


Exemplo:

Para realizarmos o alinhamento entre as duas sequências devemos primeiro
dividir cada leitura em palavras de tamanho K. Por exemplo na leitura
ACCTGCCATA que tem 10 bases, vamos utilizar uma palavra de tamanho
8. Assim a leitura gerará três palavras: ACCTGCCA, CCTGCCAT e
CTGCCATA. Faremos a mesma coisa com a segunda leitura CCTGCCATAG gerando
então as palavras: CCTGCCAT, CTGCCATA e TGCCATAG. Agora comparando
diretamente as palavras entre si, percebemos que há palavras em comum
entre ambas as leituras: CCTGCCAT e CTGCCATA . Essas duas palavras
representam 9 entre as 10 bases de cada leitura, ou seja, 90\% de
similaridade. E podemos alinhar essas duas leituras utilizando as bases
em comum.

%/figura

Apesar desse algoritmo poder não encontrar o alinhamento ótimo, ele é
mais simples que algoritmo de programação dinâmia de Smith-Waterman.
Esse algoritmo pode ser implementado usando tabelas hash, e com isso o
número de comparações aumenta linearmente em proporção ao tamanho médio
das leituras. As comparações da programação dinâmica por outro lado
aumenta entre oquadrado e o cubo do tamanho médio das leituras.

O tamanho da palavra é determinado pelo usuário. Esse parâmetro deve ser
cuidadosamente escolhido, se o tamanho da palavra for muito próxima do
tamanho da leitura, será mais difícil obter um alinhamento. No caso
contrário se o tamanho da palavra for muito diferente do tamanho da
leitura, e a busca pode retornar um número muito alto de leituras,
incluindo as não possuem pouca similaridade.



 como utilizar os alinhamentos para produzir um contig
[ definir o problema da montagem de forma geral ]

Voltando a analogia com o quebra-cabeças, utilizando o alinhamento,
sabemos como comparar as leituras e entender como as peças se
``encaixam''.  O último passo é utilizar as comparações para alinhar
todas as leituras afim de criar um ou mais contigs.
Uma representação desses alinhamentos pode ser feito criando um grafo,
onde cada leitura é um nó e os alinhamentos são as arestas. Para
realizar uma montagem, vamos todas as leituras
apenas uma vez com o melhor alinhamento possível par a par.
Modelando o problema no grafo, queremos achar um caminho nele, passando
por cada nó apenas uma vez. Esse problema é descrito como encontrar o
caminho hamiltoniano no grafo.


\chapter{Montagem nos Sequenciadores Tradicionais}

Vamos definir como sequenciadores tradicionais todos aqueles que geram
leituras acima de 500 bp e com o número de leituras de no máximo 1000.
Com essas limitações é possível utilizar a estratégia descrita a seguir
para se realizar a montagem do genoma:

1. Comparar par a par as leituras utilizando o algoritmo guloso.
2. Criar um grafo com arestas de peso relativos à comparação.
3. Achar o caminho halmiltoniano no grafo.

O sequenciamento genético tem uma grande importância na biologia
moderna. O Projeto do Genoma Humano é um exemplo da importância da
tecnologia de sequenciamento, as informações do sequenciamento levam a
compreensão de doenças relacionadas a variação genética, gerando impacto
na biologia quanto também na medicina.
[ mostrar os métodos e os algoritmos utilizados pelos montadores
  tracidionais como o phred/phrap ]

\chapter{Montagem nos Sequenciadores de Nova Geração}

[ mostrar como realizar a montagem para os sequenciadores de nova
  geração sem a utilização do grafo de bruijn:
  falar sobre os montadores desse estilo: VCAKE, SOAPDenovo]

%\chapter{Montagem nos Sequenciadores de Nova Geração utilizando grafo de
%  bruijn}

%[ mostrar como realizar a montagem utilizando o grafo de bruijn e falar
%  sobre alguns montadores desse estilo: abyss, velvet ]

%\chapter{O algoritmo Pebble e Montador Velvet}

%[ falar com mais detalhes sobre o velvet e os algoritmos utilizados por
%  ele. Colocar alguns datlhes da implementação aqui ]

