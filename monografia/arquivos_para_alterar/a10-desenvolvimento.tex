\chapter{Introdução}
Esse é um placeholder para o primeiro capítulo.

\section{Motivação}
Esse é um placeholder para a motivação

\section{Objetivos}
Esse é um placeholder para os objetivos

\section{Organização do Trabalho}
Esse é um placeholder para a organização do trabalho

\chapter{Estrutura e funcionamento básico do Domain Name System}

Desde o início das discussões sobre um espaço de nomes, sempre foi
cogitada uma solução hierárquica e distribuída para a
implementação \cite{rfc1034}.

Hoje a base de dados do DNS é indexada por nomes de domínio. Cada
domínio é um caminho em uma árvore invertida. A estrutura de árvore é
similar à estrutura do sistema de arquivos utilizado nos sistemas
\textit{Unix}. A árvore tem uma única raiz, chamado de diretório
\textit{root} (raiz) no \textit{Unix}, e representado por uma barra
(/); no DNS, esse diretório é chamado simplesmente de \textit{"raiz"}, e não
recebe nome.

Antes de prosseguir com a estrutura, é necessário fazer algumas
definições sobre os termos usados neste documento.

\section{Gramática}

A sintaxe a seguir foi feita para evitar problemas de ambiguidade e
definições, de acordo com o RFC1035 \cite{rfc1035}:

\begin{itemize}
\item $<$domínio$>$ ::= $<$subdomínio$> |$ " "
\item $<$subdomínio$>$ ::= $<$rótulo$> |$ $<$subdomínio$>$ "." $<$rótulo$>$
\item $<$rótulo$>$ ::= $<$letra$>$ [ [ $<$string$>$ ] $<$letra--dígito$>$ ]
\item $<$string$>$ ::= $<$letra--dígito--hífem$> |$ $<$letra--dígito--hífem$>$ $<$string$>$
\item $<$letra--dígito--hífem$>$ ::= $<$letra--dígito$> |$ "--"
\item $<$letra--dígito$>$ ::= $<$letra$> |$ $<$dígito$>$
\item $<$letra$>$ ::= qualquer um dos 52 caracteres alfabéticos de
  \emph{A} a \emph{Z} maiúsculos e \emph{a} a \emph{z} minúsculos.
\item $<$dígito$>$ ::= qualquer um dos dez dígitos de 0 a 9.
\end{itemize}

Note que, apesar de serem permitidas letras maiúsculas e minúsculas,
elas não tem significado diferente no DNS, de modo que o pseudo--domínio
a.b.c deve ser o mesmo que A.B.C.

Os rótulos devem seguir as regras da ARPANET para nomes de máquinas:
devem começar com uma letra e terminar com uma letra ou dígito, e ter
seu interior formado por letras, dígitos ou hífens. Rótulos devem ter
menos de 64 caracteres.

\section{Os elementos do DNS}

O DNS é formado por três elementos principais \cite{rfc1034}:

\begin{enumerate}
\item \textbf{Nomes de domínio} e \textbf{Registros}, que são as
  especificações para o espaço de nomes organizado em estrutura de
  árvore, e os dados associados aos nomes.

\item \textbf{Servidores de nomes}, que são programas de servidores que
  contêm informações sobre a estrutura do domínio de nomes. Um Servidor
  de nomes pode armazenar em cache a estrutura ou os registros de
  qualquer parte da árvore de domínio de nomes, mas geralmente um
  servidor de nomes em particular tem informação completa sobre um
  subconjunto do domínio de nomes, e ponteiros para outros servidores de
  nomes, que podem ser usados para obter informações sobre qualquer
  parte da árvore do domínio de nomes. Esses servidores que têm
  informação completa de certas partes são ditos \textbf{Autoridades}
  para essas partes. As informações de autoridades são organizadas em
  unidades chamadas \textbf{Zonas}.

\item \textbf{Resolvedores}, são programas que extraem informação dos
  servidores de nomes em resposta a uma requisição de um
  cliente. Resolvedores devem ter acesso a pelo menos um servidor de
  nomes, e usar a informação desse servidor para responder à requisição
  diretamente, ou buscar a resposta usando referências para outros
  servidores de nomes. Um resolvedor é geralmente uma Rotina do Sistema,
  que pode ser diretamente acessada por programas do usuário, sem
  necessidade de um protocolo entre ambos.
\end{enumerate}

Em nome da eficiência, esse três elementos podem ser -- e geralmente são -- acoplados em
algumas implementações (por exemplo, um servidor de nomes pode dividir
seu cache com um resolvedor, melhorando o tempo de resposta no caso
geral).

\section{Nomes de Domínio e Registros}

\subsection{Nomes de Domínio}
Como já citado anteriormente, o Sistema de Nomes de Domínios é
organizado em estrutura de árvore, onde cada nodo e cada folha contém um
conjunto de informações, podendo este conjunto ser vazio
\cite{rfc1034}. Cada nodo deve ter um rótulo, cujo tamanho varia entre 0
e 63 octetos, sendo que o nome de tamanho zero (nulo), é reservado
para a raiz. Nodos irmãos não podem ter o mesmo nome, mas não há
problema se nodos não irmãos tiverem nomes iguais.

O nome de domínio de um nodo é a lista de rótulos do nodo até a
raiz. Por convenção, os nomes são escritos e lidos da esquerda para a
direita, do mais específico (nome mais perto do nó) para o menos
específico (nodo mais perto da raiz). Os resolvedores tratam da mesma
forma letras maiúsculas e minúsculas, mas os nomes de domínios devem
guardar rótulos sem ignorar essa diferença, mantendo o nome original do
domínio. A justificativa dessa decisão é que, eventualmente, pode ser
necessário diferenciar nomes em caixa alta e caixa baixa, e a
implementação atual garante que nenhum serviço tenha que ser
drasticamente alterado \cite{rfc1034}.

Para simplificar implementações do DNS, o tamanho máximo de octetos de
um nome de domínio é limitado a 255 caracteres.

\subsection{Registros}

Cada nodo da árvore de nomes de domínio possui um conjunto de
informações de registros, que pode ser vazio. A ordenação de registros
em um conjunto não é significante, e não precisa ser mantida. Assumimos
que um registro tem as seguintes informações \cite{comer}:

\begin{tabular}{ l p{0.82\textwidth} }
\textbf{Dono} & Em qual nome de domínio esse registro é
  encontrado.\\
\textbf{Tipo} & É um código de 16 bits; guarda o tipo de recurso
  desse registro. Como padrão, são especificados os seguintes tipos
  \cite{rfc1034}:\\

  & \begin{tabular}{ l p{0.70\textwidth} }
      \emph{A} & Endereço de um servidor em notação IPv4\\
      \emph{AAAA} & Endereço de um servidor em notação IPv6\\
      \emph{CNAME} & Nome Canônico de um \textit{Alias}\\
      \emph{HINFO} & Traz informações sobre CPU e Sistema Operacional do
      servidor.\\
      \emph{MX} & Informações sobre o comutador de \textit{e-mails}
      (\textit{Mail eXchanger}) associado ao servidor.\\
      \emph{NS} & Nome do servidor com autoridade sobre o domínio.\\
      \emph{PTR} & Ponteiro para outro domínio de nomes.\\
      \emph{SOA} & \textit{Start of Authority} -- Identifica o início de
      uma Zona de Autoridade.
    \end{tabular}\\

  \textbf{Classe} & É um valor de 16 bits que identifica a família de um
  protocolo ou uma instância de um protocolo. Os valores especificados
  \cite{rfc1034} são:\\
  & \begin{tabular}{ l p{0.70\textwidth} }
      \emph{IN} & O sistema Internet\\
      \emph{CH} & O sistema \textit{Chaos}
    \end{tabular}\\
  \textbf{TTL} & \textit{Time to Live}. Esse campo é um inteiro de 32
  bits, e representa o tempo máximo, em segundos, que um registro pode
  ficar armazenado em cache. Ao fim desse tempo, o registro deve ser
  descartado.\\
  \textbf{RDATA} & O campo com o \textbf{tipo} dos dados, e, eventualmente, dados
  dependentes da classe dos dados.\\
\end{tabular}

As figuras \ref{pacote-cliente} e \ref{pacote-servidor} demonstram todos os campos de um pacote de requisição DNS.


\begin{figure}[h] % [especificador de posição]:exemplos [htbp] - h:aqui, t:topo, b:baixo, p:página especial, !: desconsiderar parâmetros internos
\begin{center}
\includegraphics[scale=.7]{./figuras/dns-packet-client-server.eps} %Opções: width (largura em pt ou cm ou vezes se não houver unidade de medida), height (altura em pt, cm ou vezes se não houver unidade de medida), angle (rotação em graus), scale (escala em vezes 0.5= 50%,1.5=150%, etc )
\end{center}
\caption[Pacote DNS do cliente para o servidor]{Esquema dos campos de um pacote DNS sendo enviado de um cliente para um servidor, de acordo com o RFC1034 \cite{rfc1034}, retirado de \cite{steve}}
\label{pacote-cliente}
\end{figure}

\begin{figure}[h] % [especificador de posição]:exemplos [htbp] - h:aqui, t:topo, b:baixo, p:página especial, !: desconsiderar parâmetros internos
\begin{center}
\includegraphics[scale=.7]{./figuras/dns-packet-server-client.eps} %Opções: width (largura em pt ou cm ou vezes se não houver unidade de medida), height (altura em pt, cm ou vezes se não houver unidade de medida), angle (rotação em graus), scale (escala em vezes 0.5= 50%,1.5=150%, etc )
\end{center}
\caption[Pacote DNS do servidor para o cliente]{Esquema dos campos de um pacote DNS sendo enviado de um servidor para um cliente, de acordo com o RFC1034 \cite{rfc1034}, retirado de \cite{steve}}
\label{pacote-servidor}
\end{figure}



\section{Servidores de nomes}

Servidores de nomes são repositórios de informações que, juntos, compõe
a árvore do DNS \cite{albitz}. As informações contidas em um servidor de
nomes pode ser obtida através de um arquivo local (chamado
\textit{master file}) ou a partir de outros servidores de nomes.

Os servidores que obtém os dados por um arquivo de configuração são
chamados de primários, e os outros, secundários. A informação de um
servidor primário é replicada para vários servidores secundários para
garantir a redundância dos dados.

Todo servidor tem informação autoritária sobre uma zona, e alguns
servidores podem ser autoridades para várias zonas. Nos servidores de autoridade, os nomes para os quais eles são autoridade estão guardados no Masterfile, e suas traduções nunca ficam em cache. Para garantir a segurança por redundância, um domínio deve estar em pelo menos dois servidores de autoridade, e não existe um máximo, além desses dois servidores necessariamente devem estar topologicamente separados \cite{ns-rules}.

\section{Tradução de um nome}

Do ponto de vista de um Resolvedor recursivo, o algoritmo em alto nível para traduzir um nome tem 4 passos \cite{rfc1034}:

\begin{enumerate}
  \item Procurar a resposta em informação local (cache). Se encontrada, retornar a resposta ao cliente
  \item Encontrar os melhores Servidores de Nomes para perguntar a tradução
  \item Enviar a pergunta para todos os servidores encontrados até que um deles responda
  \item Analise a resposta:
  \begin{itemize}
    \item Se a resposta contiver um erro ou uma tradução do nome requisitado, guarde o resultado em cache e retorne-o para o cliente
    \item Se a resposta apontar para uma zona melhor para fazer a pergunta, guarde essa informação em cache e volte ao passo 2
    \item Se a resposta contiver um CNAME, isso é, um nome canônico, isso significa que o nome procurado era apenas um \textit{alias} para esse nome. Guarde a tradução do nome normal para o nome canônico em cache, mude o nome buscado para aquele obtido na resposta com o CNAME e volte ao passo 1
    \item Se a resposta mostrar algum erro de servidor, ou qualquer outro tipo de resposta não prevista, exclua esse servidor da lista e volte ao passo 3
  \end{itemize}
\end{enumerate}

O algoritmo seguido por um Servidor de Nomes para lidar com uma requisição de tradução é um pouco mais longo, mas para o objetivo deste trabalho, ele não é importante. Maiores informações podem ser encontradas no RFC1034 \cite[p.~24--25]{rfc1034}.

\chapter{Falha de segurança no DNS}

Em Julho de 2008 foi anunciado pelo \textit{CERT} (\textit{Computer Emergency Readiness Team}) que o pesquisador de segurança Dan Kaminsky havia descoberto uma falha fundamental no protocolo do DNS, definido nos RFC's 1034 \cite{rfc1034} e 1035 \cite{rfc1035}.

Para entender melhor a natureza dessa falha, é preciso antes entender como funcionava a segurança nas consultas de DNS antes de 2008.

\section{Protocolo antigo de segurança}

Como visto anteriormente, ao receber uma pergunta de um usuário, o Resolvedor envia requisições para vários servidores ao mesmo tempo; a resposta que ele receber primeiro será considerada como a correta, e as outras serão ignoradas \cite{rfc1034}. Isso cria uma condição de corrida entre os servidores sendo consultados.

Para garantir que a resposta vem de um dos servidores, cada requisição enviada possui um número de identificação único, chamado de \textit{query ID}. A resposta de uma requisição deveria ter o mesmo \textit{query ID} da requisição.

Nas primeiras versões das implementações, esse número era sequencial, o que fazia com que fosse muito fácil descobrir qual o próximo número no contador local do Resolvedor \cite{steve}. Desse modo, é possível forjar uma resposta a uma requisição, usando o endenreço de um dos servidores de nome de autoridade, e entregar uma resposta falsa, que será guardada em cache e usada para outras perguntas sobre a mesma zona.

As versões posteriores das implementações do DNS tomaram um cuidado maior com a segurança desse número de identificação e o tornaram aleatório. Esse protocolo de segurança durou até 2008, quando o pesquisador Kaminsky descobriu uma falha que permitia o envenenamento da cache, que atingia a maioria das implementações do DNS (as poucas exceções foram \textit{djbdns}, \textit{PowerDNS}, \textit{MaraDNS} e \textit{Unbound}).

\section{A falha Kaminsky}

Com a aleatoriedade do número de \textit{queryID}, ficou muito mais complexo usar o ataque para envenenamento de cache, uma vez que esse número é formado por 16 bits, ou seja, são 65.536 possíveis valores, e uma janela de tempo razoavelmente pequena para que esse número seja adivinhado.

Mas mesmo a chance sendo pequena, Kaminsky notou que não existia um limite de tentativas. Segundo o próprio Kaminsky, em uma entrevista para a versão online da revista Wired: "é como uma corrida em que você decide quando será a largada" \cite{interview}.

Ao lançar o ataque escrito por Kaminsky na ferramenta de teste Metasploit, observa-se que é possível enviar em média 100 respostas forjadas para cada requisição enviada. Isso é, aproximadamente, uma chance em 656, o que pode parecer uma possibilidade tão pequena que deveria ser descartada. No entanto, como não existe limite de tentativas, e disparar requisições aleatórias é um processo muito rápido, Kaminsky reportou que seu ataque envenenava o cache do servidor alvo em cerca de 10 segundos \cite{steve}. Podemos observar o ataque esquematizado na figura \ref{ataque}.

\begin{figure}[h] % [especificador de posição]:exemplos [htbp] - h:aqui, t:topo, b:baixo, p:página especial, !: desconsiderar parâmetros internos
\begin{center}
\includegraphics[scale=.5]{./figuras/badguy-kaminsky-poison-dns.eps} %Opções: width (largura em pt ou cm ou vezes se não houver unidade de medida), height (altura em pt, cm ou vezes se não houver unidade de medida), angle (rotação em graus), scale (escala em vezes 0.5= 50%,1.5=150%, etc )
\end{center}
\caption[Esquema do ataque]{Esquema do ataque Kaminsky, retirado de \cite{steve}}
\label{ataque}
\end{figure}

Até então a única coisa feita foi reinventar um ataque de envenenamento que já existia e teoricamente fora eliminado. Mas Kaminsky foi além. O normal do ataque é simplesmente roubar um domínio específico. Por exemplo, no domínio \emph{inf.ufpr.br}, o que ataques clássicos fariam é roubar para si a tradução do nome \emph{inf}, mas, seguindo as regras do DNS \cite{rfc1034}, se um servidor de autoridade responder em sua sessão adicional que ele também é uma autoridade para o \emph{.br}, o cache do resolvedor alvo será sobrescrito, e então esse ataque pode roubar os chamados \textit{Top Level Domains} (TLD), que são os domínios mais próximos da raiz, e tem mais nodos sob sua delegação.

Seguindo o mesmo padrão, seria possível roubar a autoridade do \emph{.com}, \emph{.net}, e todos os principais TLD's de qualquer servidor de nome que não seja autoridade para esse TLD \cite{steve}.

A técnica consiste em gerar uma string aleatória sob o domínio que se deseja envenenar, e sempre exigir uma resposta de autoridade, negando assim qualquer resposta que possa haver em cache e exigindo que o resolvedor envie requisições para outros servidores. Ao receber uma resposta, os registros em cache eram sempre reescritos com a informação mais recente, ou seja, ainda que o domínio procurado já estivesse em cache, ele seria substituído pela resposta forjada.

Essa técnica passou a ser conhecida como Ataque Kaminsky.

\section{Riscos do ataque}

A organização em árvore fez com que nenhum nodo do DNS tenha conhecimento da rede inteira, apenas da zona pela qual está responsável.

São raros os programas que não usam DNS. Especulou-se se o problema de envenenamento não poderia ser resolvido usando SSL para sites de informações sigilosas, mas muitas entidades certificadoras enviam seus certificados por e-mail, que por sua vez usa o DNS. Se um atacante conseguir envenenar o resolvedor usado por uma entidade certificadora, pode conseguir receber certificados válidos para vários sites que podem ser forjados.

Além dos riscos óbvios de poder forjar sites que recebem dados sigilosos, como bancos, o envenenamento de um servidor muito requisitado permite ao atacante induzir anomalias do tipo \textit{Flash Crowd}\footnote{Flash Crowd caracteriza quando, por algum motivo, uma página na internet fica muito popular. O excesso de visitas em um curto período de tempo cria um DDoS e faz com que a página fique indisponível \cite{flashcrowd}}, redirecionando um tráfego muito grande para o site que será a vítima.

Como já mencionado, servidores de e-mail precisam de traduções de nomes, inclusive e-mails bancários, governamentais e militares, contendo mensagens confidenciais. Em outras palavras uma série de envenenamentos de cache bem sucedidos permitiria ao atacante controle sobre o tráfego na internet e acesso a muitas informações confidenciais.

\section{Correção de segurança}

Os 16 bits que compõe o identificador da mensagem acabou se revelando, apesar de tudo, um espaço de busca relativamente pequeno. A primeira ideia que pode ocorrer é aumentar esse espaço para 32 bits; no entanto isso é impossível de ser feito em pouco tempo, uma vez que uma mudança no formato do pacote quebraria o DNS na internet \cite{steve}. A solução foi copiada do \textit{djbdns}, uma das poucas implementações que não eram vulneráveis ao ataque.

Inventado pelo criptógrafo e professor da Universidade de Ilinóis, Chicago, Daniel J. Bernstein, o \textit{djbdns} funciona de maneira parecida aos outros programas afetados pelo ataque Kaminsky, mas com uma difereça fundamental.

Era prática comum usar a porta UDP 53 para enviar requisições entre servidores e resolvedores DNS \cite{rfc1035}, mas o \textit{djbdns} usava uma porta aleatória a cada nova requisição, uma vez que usar a porta 53 é apenas uma recomendação e não uma regra. Com isso, além de acertar o número de identificação da requisição, também é preciso que a resposta seja enviada para a porta correta.

Isso diminui drasticamente as chances de um atacante ser bem sucedido, uma vez que é prática comum servidores pré-alocarem 2500 portas UDP para serem aleatoriamente usadas pelo DNS \cite{steve}. Para efeitos de cálculos, vamos contar como sendo 2048, ou $2^11$ portas pré-alocadas. Isso resulta em:

$2^11$ portas $* 2^16$ possibilidades de identificadores $= 2^27$, ou 32 milhões de combinações possíveis.

Ainda que um atacante consiga produzir 100 pacotes por requisição, as chances dele conseguir acertar a combinação e envenenar o cache de um servidor é de uma em 320 mil, isto é, aproximadamente 490 vezes menos provável que a versão antiga da implementação.

Além disso, alguns programas populares que implementam o DNS, como o BIND, mudaram as regras sobre quando um registro em cache pode ser sobrescrito. ***\textbf{(Albini, foi o Kaminsky quem me falou isso por e-mail, tem como eu colocar um e-mail como referência?)}***

A descoberta do ataque Kaminsky promoveu a maior atualização em massa desde que o DNS foi inventado \cite{steve}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Modelo para escrever TCCs, dissertações e teses utilizando LaTeX, ABNTeX e BibTeX
% Autor/E-Mail: Robinson Alves Lemos/contato@robinson.mat.br/robinson.a.l@bol.com.br
% Data: 19/04/2008 
% Colaboradore(s)/E-Mail(s):
% Caso queira colaborar, entre em contato pelo e-mail e informe alterações que realizou.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

