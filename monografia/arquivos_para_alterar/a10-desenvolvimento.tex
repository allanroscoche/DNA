\chapter{Introdução}
Esse é um placeholder para o primeiro capítulo.

\section{Motivação}
Esse é um placeholder para a motivação

\section{Objetivos}
Esse é um placeholder para os objetivos

\section{Organização do Trabalho}
Esse é um placeholder para a organização do trabalho

\chapter{Estrutura e funcionamento básico do Domain Name System}

Desde o início das discussões sobre um espaço de nomes, sempre foi
cogitada uma solução hierárquica e distribuída para a
implementação \cite{rfc1034}.

Hoje a base de dados do DNS é indexada por nomes de domínio. Cada
domínio é um caminho em uma árvore invertida. A estrutura de árvore é
similar à estrutura do sistema de arquivos utilizado nos sistemas
\textit{Unix}. A árvore tem uma única raiz, chamado de diretório
\textit{root} (raiz) no \textit{Unix}, e representado por uma barra
(/); no DNS, esse diretório é chamado simplesmente de \textit{"raiz"}, e não
recebe nome.

Antes de prosseguir com a estrutura, é necessário fazer algumas
definições sobre os termos usados neste documento.

\section{Gramática}

A sintaxe a seguir foi feita para evitar problemas de ambiguidade e
definições, de acordo com o RFC1035 \cite{rfc1035}:

\begin{itemize}
\item $<$domínio$>$ ::= $<$subdomínio$> |$ " "
\item $<$subdomínio$>$ ::= $<$rótulo$> |$ $<$subdomínio$>$ "." $<$rótulo$>$
\item $<$rótulo$>$ ::= $<$letra$>$ [ [ $<$string$>$ ] $<$letra--dígito$>$ ]
\item $<$string$>$ ::= $<$letra--dígito--hífem$> |$ $<$letra--dígito--hífem$>$ $<$string$>$
\item $<$letra--dígito--hífem$>$ ::= $<$letra--dígito$> |$ "--"
\item $<$letra--dígito$>$ ::= $<$letra$> |$ $<$dígito$>$
\item $<$letra$>$ ::= qualquer um dos 52 caracteres alfabéticos de
  \emph{A} a \emph{Z} maiúsculos e \emph{a} a \emph{z} minúsculos.
\item $<$dígito$>$ ::= qualquer um dos dez dígitos de 0 a 9.
\end{itemize}

Note que, apesar de serem permitidas letras maiúsculas e minúsculas,
elas não tem significado diferente no DNS, de modo que o pseudo--domínio
a.b.c deve ser o mesmo que A.B.C.

Os rótulos devem seguir as regras da ARPANET para nomes de máquinas:
devem começar com uma letra e terminar com uma letra ou dígito, e ter
seu interior formado por letras, dígitos ou hífens. Rótulos devem ter
menos de 64 caracteres.

\section{Os elementos do DNS}

O DNS é formado por três elementos principais \cite{rfc1034}:

\begin{enumerate}
\item \textbf{Nomes de domínio} e \textbf{Registros}, que são as
  especificações para o espaço de nomes organizado em estrutura de
  árvore, e os dados associados aos nomes.

\item \textbf{Servidores de nomes}, que são programas de servidores que
  contêm informações sobre a estrutura do domínio de nomes. Um Servidor
  de nomes pode armazenar em cache a estrutura ou os registros de
  qualquer parte da árvore de domínio de nomes, mas geralmente um
  servidor de nomes em particular tem informação completa sobre um
  subconjunto do domínio de nomes, e ponteiros para outros servidores de
  nomes, que podem ser usados para obter informações sobre qualquer
  parte da árvore do domínio de nomes. Esses servidores que têm
  informação completa de certas partes são ditos \textbf{Autoridades}
  para essas partes. As informações de autoridades são organizadas em
  unidades chamadas \textbf{Zonas}.

\item \textbf{Resolvedores}, são programas que extraem informação dos
  servidores de nomes em resposta a uma requisição de um
  cliente. Resolvedores devem ter acesso a pelo menos um servidor de
  nomes, e usar a informação desse servidor para responder à requisição
  diretamente, ou buscar a resposta usando referências para outros
  servidores de nomes. Um resolvedor é geralmente uma Rotina do Sistema,
  que pode ser diretamente acessada por programas do usuário, sem
  necessidade de um protocolo entre ambos.
\end{enumerate}

Em nome da eficiência, esse três elementos podem ser -- e geralmente são -- acoplados em
algumas implementações (por exemplo, um servidor de nomes pode dividir
seu cache com um resolvedor, melhorando o tempo de resposta no caso
geral).

\section{Nomes de Domínio e Registros}

\subsection{Nomes de Domínio}
Como já citado anteriormente, o Sistema de Nomes de Domínios é
organizado em estrutura de árvore, onde cada nodo e cada folha contém um
conjunto de informações, podendo este conjunto ser vazio
\cite{rfc1034}. Cada nodo deve ter um rótulo, cujo tamanho varia entre 0
e 63 octetos, sendo que o nome de tamanho zero (nulo), é reservado
para a raiz. Nodos irmãos não podem ter o mesmo nome, mas não há
problema se nodos não irmãos tiverem nomes iguais.

O nome de domínio de um nodo é a lista de rótulos do nodo até a
raiz. Por convenção, os nomes são escritos e lidos da esquerda para a
direita, do mais específico (nome mais perto do nó) para o menos
específico (nodo mais perto da raiz). Os resolvedores tratam da mesma
forma letras maiúsculas e minúsculas, mas os nomes de domínios devem
guardar rótulos sem ignorar essa diferença, mantendo o nome original do
domínio. A justificativa dessa decisão é que, eventualmente, pode ser
necessário diferenciar nomes em caixa alta e caixa baixa, e a
implementação atual garante que nenhum serviço tenha que ser
drasticamente alterado \cite{rfc1034}.

Para simplificar implementações do DNS, o tamanho máximo de octetos de
um nome de domínio é limitado a 255 caracteres.

\subsection{Registros}

Cada nodo da árvore de nomes de domínio possui um conjunto de
informações de registros, que pode ser vazio. A ordenação de registros
em um conjunto não é significante, e não precisa ser mantida. Assumimos
que um registro tem as seguintes informações \cite{comer}:

\begin{tabular}{ l p{0.82\textwidth} }
\textbf{Dono} & Em qual nome de domínio esse registro é
  encontrado.\\
\textbf{Tipo} & É um código de 16 bits; guarda o tipo de recurso
  desse registro. Como padrão, são especificados os seguintes tipos
  \cite{rfc1034}:\\

  & \begin{tabular}{ l p{0.70\textwidth} }
      \emph{A} & Endereço de um servidor em notação IPv4\\
      \emph{AAAA} & Endereço de um servidor em notação IPv6
      \emph{CNAME} & Nome Canônico de um \textit{Alias}\\
      \emph{HINFO} & Traz informações sobre CPU e Sistema Operacional do
      servidor.\\
      \emph{MX} & Informações sobre o comutador de \textit{e-mails}
      (\textit{Mail eXchanger}) associado ao servidor.\\
      \emph{NS} & Nome do servidor com autoridade sobre o domínio.\\
      \emph{PTR} & Ponteiro para outro domínio de nomes.\\
      \emph{SOA} & \textit{Start of Authority} -- Identifica o início de
      uma Zona de Autoridade.
    \end{tabular}\\

  \textbf{Classe} & É um valor de 16 bits que identifica a família de um
  protocolo ou uma instância de um protocolo. Os valores especificados
  \cite{rfc1034} são:\\
  & \begin{tabular}{ l p{0.70\textwidth} }
      \emph{IN} & O sistema Internet\\
      \emph{CH} & O sistema \textit{Chaos}
    \end{tabular}\\
  \textbf{TTL} & \textit{Time to Live}. Esse campo é um inteiro de 32
  bits, e representa o tempo máximo, em segundos, que um registro pode
  ficar armazenado em cache. Ao fim desse tempo, o registro deve ser
  descartado.\\
  \textbf{RDATA} & O campo com o \textbf{tipo} dos dados, e, eventualmente, dados
  dependentes da classe dos dados.\\
\end{tabular}

\section{Servidores de nomes}

Servidores de nomes são repositórios de informações que, juntos, compõe
a árvore do DNS \cite{albitz}. As informações contidas em um servidor de
nomes pode ser obtida através de um arquivo local (chamado
\textit{master file}) ou a partir de outros servidores de nomes.

Os servidores que obtém os dados por um arquivo de configuração são
chamados de primários, e os outros, secundários. A informação de um
servidor primário é replicada para vários servidores secundários para
garantir a redundância dos dados.

Todo servidor tem informação autoritária sobre uma zona, e alguns
servidores podem ser autoridades para várias zonas. Nos servidores de autoridade, os nomes para os quais eles são autoridade estão guardados no Masterfile, e suas traduções nunca ficam em cache. Para garantir a segurança por redundância, um domínio deve estar em pelo menos dois servidores de autoridade, e não existe um máximo, além desses dois servidores necessariamente devem estar topologicamente separados \cite{ns-rules}.

\section{Tradução de um nome}

Do ponto de vista de um Resolvedor recursivo, o algoritmo em alto nível para traduzir um nome tem 4 passos \cite{rfc1034}:

\begin{enumerate}
  \item Procurar a resposta em informação local (cache). Se encontrada, retornar a resposta ao cliente
  \item Encontrar os melhores Servidores de Nomes para perguntar a tradução
  \item Enviar a pergunta para todos os servidores encontrados até que um deles responda
  \item Analise a resposta:
  \begin{itemize}
    \item Se a resposta contiver um erro ou uma tradução do nome requisitado, guarde o resultado em cache e retorne-o para o cliente
    \item Se a resposta apontar para uma zona melhor para fazer a pergunta, guarde essa informação em cache e volte ao passo 2
    \item Se a resposta contiver um CNAME, isso é, um nome canônico, isso significa que o nome procurado era apenas um \textit{alias} para esse nome. Guarde a tradução do nome normal para o nome canônico em cache, mude o nome buscado para aquele obtido na resposta com o CNAME e volte ao passo 1
    \item Se a resposta mostrar algum erro de servidor, ou qualquer outro tipo de resposta não prevista, exclua esse servidor da lista e volte ao passo 3
  \end{itemize}
\end{enumerate}

O algoritmo seguido por um Servidor de Nomes para lidar com uma requisição de tradução é um pouco mais longo, mas para o objetivo deste trabalho, ele não é importante. Maiores informações podem ser encontradas no RFC1034 \cite[p.~24--25]{rfc1034}.

\chapter{Falha de segurança no DNS}

Em Julho de 2008 foi anunciado pelo \textit{CERT} (\textit{Computer Emergency Readiness Team}) que o pesquisador de segurança Dan Kaminsky havia descoberto uma falha fundamental no protocolo do DNS, definido nos RFC's 1034 \cite{rfc1034} e 1035 \cite{rfc1035}.

Para entender melhor a natureza dessa falha, é preciso antes entender como funcionava a segurança nas consultas de DNS antes de 2008.

\section{Protocolo antigo de segurança}

Como visto anteriormente, ao receber uma pergunta de um usuário, o Resolvedor envia requisições para vários servidores ao mesmo tempo; a resposta que ele receber primeiro será considerada como a correta, e as outras serão ignoradas \cite{rfc1034}. Isso cria uma condição de corrida entre os servidores sendo consultados.

Para garantir que a resposta vem de um dos servidores, cada requisição enviada possui um número de identificação único, chamado de \textit{query ID}. A resposta de uma requisição deveria ter o mesmo \textit{query ID} da requisição.

Nas primeiras versões das implementações, esse número era sequencial, o que fazia com que fosse muito fácil descobrir qual o próximo número no contador local do Resolvedor \cite{steve}. Desse modo, é possível forjar uma resposta a uma requisição, usando o endenreço de um dos servidores de nome de autoridade, e entregar uma resposta falsa, que será guardada em cache e usada para outras perguntas sobre a mesma zona.

As versões posteriores das implementações do DNS tomaram um cuidado maior com a segurança desse número de identificação e o tornaram aleatório. Esse protocolo de segurança durou até 2008, quando o pesquisador Kaminsky descobriu uma falha que permitia o envenenamento da cache, que atingia a maioria das implementações do DNS (as poucas exceções foram \textit{djbdns}, \textit{PowerDNS}, \textit{MaraDNS} e \textit{Unbound}).

\section{A falha Kaminsky}

Com a aleatoriedade do número de \textit{queryID}, ficou muito mais complexo usar o ataque para envenenamento de cache, uma vez que esse número é formado por 16 bits, ou seja, são 65.536 possíveis valores, e uma janela de tempo razoavelmente pequena para que esse número seja adivinhado.

Mas mesmo a chance sendo pequena, Kaminsky notou que não existia um limite de tentativas. Segundo o próprio Kaminsky, em uma entrevista para a versão online da revista Wired:
\begin{cite}
é como uma corrida em que você decide quando será a largada
\end{cite}\cite{interview}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Modelo para escrever TCCs, dissertações e teses utilizando LaTeX, ABNTeX e BibTeX
% Autor/E-Mail: Robinson Alves Lemos/contato@robinson.mat.br/robinson.a.l@bol.com.br
% Data: 19/04/2008 
% Colaboradore(s)/E-Mail(s):
% Caso queira colaborar, entre em contato pelo e-mail e informe alterações que realizou.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

