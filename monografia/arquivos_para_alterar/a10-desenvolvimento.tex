\chapter{Introdução}
Um pré-requisito para a compreensão completa da biologia de um organismo
é determinar toda a sua sequência genética. Agora nesse momento, há
vários projetos de sequenciamento genético em andamento para vários
organismos. Uma grande parte desses projetos é a montagem do DNA desses
seres vivos, onde técnicas cada vez mais sofisticadas de computação vem
sendo utilizadas para superar esse desafio.

\section{Motivação}
Com o desenvolvimento de novos sequenciadores capazes de gerar vários
gigabytes de dados em algumas horas, os softwares necessitam cada vez
mais de sofisticações para conseguir lidar com esses dados. Vários
montadores foram criados para conseguir mostrar resultados em tempo
hábil, contudo máquinas cada vez mais poderosas são necessárias.
Montadores como o Velvet necessitam de quantidades cada vez maiores de
memória. Sendo que apenas computadores de grande porte conseguem atendem
as necessidades do software. Estudar as possibilidades de economia de
memória para que seja possível fazer o sequenciamento de seres maiores
nas máquinas atuais e a capacidade de fácil distribuição do trabalho
para que vários processadores possam trabalhar ao mesmo tempo.

\section{Objetivos}
O objetivo do projeto foi criar alguma modificação na criação da tabela
hash do velvet, de uma maneira que ela utilizasse menos memória e que
pudesse ser criada paralelamente de uma forma eficiente.

\section{Organização do Trabalho}
O capítulo 2 trata dos sequenciadores genéticos e como eles geram o
problema computacional da montagem, támbém realiza uma perspectiva
histórica de como o sequenciamento vem evoluindo. Já o capítulo 3 trata
do problema da montagem de uma forma geral e qual a complexidade
computacional para tratá-lo. O capítulo 4 trata o velvet e como ele
trata do problema da montagem. O capíutlo 5 mostra como foram
implementadas as alterações na tabela hash e como foi realizada a
paralelização. O capítulo 6 mostra os resultados obtidos.

\chapter{Sequenciadores}
\section{Sequenciadores Clássicos}
\subsection{Sequenciamento Dirigido}
O método mais comum de sequenciamento dirigido é o primer walking. Esse
método consiste em identificar uma sequência conhecida, e a partir dela
ler a sequencia adjacente. Essa nova sequência então é utilizado para
identificar a próxima leitura e então uma nova sequencia adjacente é
gerada.. Dessa maneira ``anda-se'' por toda a sequência e o cromossomo é
lido do começo ao fim. O principal problema  do sequenciamento dirigido
é dele ser sequencial e extremamente lento.
\subsection{Sequenciamento Aleatório}
A estratégia shotgun para o sequenciamento genético de todo organismo
consiste em quebrar o DNA em segmentos de vários tamanhos e então clonar
esses segmentos em vetores. Esses segmentos então são sequenciados e
várias leituras aleatórias do organismo são geradas. Essas leituras
então são comparadas e montadas, gerando assim várias sequências maiores
chamdas de contigs. A combinação de todos os contigs então é realizada
para descobrir o DNA completo do organismo, normalmente técnicas de
sequenciamento dirigido é realizado para sequenciar as partes faltantes.

\section{Sequenciadores de Nova Geração}
Três plataformas para o sequenciamento massivamente paralelo como o
Roche/454 FLX, o Illumina/Solexa Genome Analizer e o Applied Biosystems
SOLiD System. Esses instrumentos permitem uma grande simplificação no
processo de preparação do sequenciamento do DNA, o que economiza tempo e
um requerimento menor assossiado aos equipamentos muito automatizados,
com muitos passos e baseados em clonagem. Por métodos diferentes, cada
tecnologia procura amplificar cada fita dos fragmentos de amostra e
realiza várias reações nelas.
Uma outra diferença das novas plataformas é a diferença do tempo
necessário para a geração dos dados. Os sequenciadores clássicos
necessivam de tempos entre 8 horas e 10 dias.
O rendimento dos dados dos experimentos também mudaram drasticamente, ao
ínvés de 96 leituras com até 750bp cada. Os novos sequenciadores variam
entre centenas de milhares de leituras até 10 milhões de leituras.


\chapter{O Problema da Montagem}
\section{Estratégia do Consenso de Sobreposições}
Os sequenciadores conseguem ler apenas um número limitado de bases, esse
número limitado de bases é chamado de leitura. A leitura é um pedaço do
DNA que está sendo sequenciado, contudo a sua posição original é
desconhecida. Essas leituras são comparadas entre si e organizadas para
tentar criar uma sequencia única. A sequencia criada através da
comparação e junção entre diversas leituras é chamada de contig. As
leituras podem ser comparadas através de suas sobreposições, com elas
monta-se um grafo em que cada vértice é uma leitura e cada aresta
se existir uma sobreposição[pevzner] entre as leituras. O problema de
montagem é então modelado para o problema do Caminho Hamiltoniano, onde
cada vértice precisa ser visitado uma única vez.

\section{Dificuldades do Consenso de Sobreposições}
O problema do Caminho Hamiltoniado é NP-Completo e não existem
algoritmos eficientes para resolvê-lo. Contudo alguns programas utilizam
essa estratégia para a montagem dos fragmentos como o PHRAP, CAP, TIGR e
CELERA. Esses programas contudo só conseguem realizar a montagem para
sequenciadores de primeira geração onde o número de leituras era menor
que 10 mil, e cada leitura possuia entre 400bp e 900bp. Sequenciadores de
segunda geração geram facilmente mais de 10 milhões de leituras onde
cada leitura possui entre 35bp até 50bp no ABI Solid. Devido ao grande
aumento no número de leituras esses programas não conseguem tratar em
tempo hábil o problema devido a natureza exponencial da estratégia da montagem.
%https://products.appliedbiosystems.com/ab/en/US/adirect/ab?cmd=catNavigate2&catID=600530&tab=DetailInfo

\section{Grafo de Bruijn Teórico}
O grafo de Bruijn é montado criando vértices que são partes repetidas de
leituras, ou seja, as leituras são unidas. Dessa maneira, cada repetição
corresponde a uma aresta ao invés de uma coleção de vértices no grafo
de sobreposições. O mais importante é que agora o problema de montagem é modelado em encontrar um
caminho em que cada aresta é visitada apenas uma vez, um problema do
Caminho Euleriano[Pevzner-2001]. Ao contrário do Caminho Hamiltoniano, o
problema do Caminho Euleriano possui uma complexidade menor, pois
existem algoritmos em rodam tem tempo linear. Essa é a fundamental
diferença entre as duas estratégias. Apesar do grafo de Bruijn possuir
vantagens em sua complexidade, não é muito claro como encontrar um jeito
de construí-lo. Os vértices criados através de leituras unidas necessita
do conhecimento do DNA completo, que não está disponível até a fase
final.

\chapter{O montador Velvet}

\section{K-mers}
Os k-mers são os vértices do grafo de Bruijn no Velvet. Os k-mers são
formados por k-1 bases adjacentes. Cada nó é unido ao seu inverso,
que representa a ordem inversa do seu complemento dos nucleotídios. A
união do nó com seu inverso é chamado bloco. Cada bloco tem dois lados
distintos, cada lado é ligado por um ``arco'' direcionado. Contudo se um
arco vai de A pra B, um arco simétrico vai de /B pra /A. Os nós e os
arcos são mapenado como ``caminhos'' atravessando o grafo.[velvet]

\section{Grafo de Bruijn}
É realizado uma hash das leituras de acordo com o tamanho definido pelos
k-mers. A variável k é limitada pelo tamanho da leitura sendo
utilizada. K-mers pequenos aumentam a conectividade do grapo ao mesmo
tempo aumentam a chance de repetições ambíguas no grafo. Logo é
necessário um equilibrio entre sensibilidade e especificidade
determinado pelo k(cf. Methods).
Para cada k-mers encontrado no conjunto de leituras, a tabela hash
armazena o ID da primeira leitura encontrada para aquele k-mer e a sua
posição encontrada dentro da leitura. Cada k-mer é armazenado
simultaneamente com o seu complemento reverso. Para garantir que cada
k-mer não possa ser o seu próprio complemento reverso, k tem que ser um
número impar. Essa primeira leitura permite que cada leitura seja
reescrita como um conjunto de k-mers combinados com suas sobreposições
na tabela hash. Essa representação de leituras é chamada de ``roadmap''
e é o foco do trabalho realizado.


\section{Remoção de Erros}
A correção de erros é realizada depois que o grafo é formado para que
seja possível operações simultâneas no conjunto de leituras. Uma
abordagem simplista seria remover todos os nós com cobertura baixa,
contudo isso também eliminaria variações biológicas legítimas que tenham
uma representação baixa. O Velvet utiliza métodos que focam
características topológicas. Informações errôneas geram três tipos de
estruturas: ``tips'' em função dos erros nos arcos do reads, ``bulges''
devido a leituras erradas ou a ``tips'' próximas que estejam conectadas,
e conexões erradas devido a defeitos de clonagem. Os três erros são
removidos consecutivamente.

%\chapter{Falha de segurança no DNS}
%Em Julho de 2008 foi anunciado pelo \textit{CERT} (\textit{Computer Emergency Readiness Team} -- Time de prontidão a emergências computacionais) que o pesquisador de segurança Dan Kaminsky havia descoberto uma falha fundamental no protocolo do DNS, definido nos RFC's 1034 \cite{rfc1034} e 1035 \cite{rfc1035}.


\chapter{Nova proposta da montagem dos k-mers}
\section{Implementação Enxuta dos Reads}
A implementação das leituras é realizada de uma forma a economizar o
máximo de memória. Cada base de uma leitura utiliza apenas 2 bits por
base, num total de 4 nucleotídeos por byte. Utilizando 4 vezes menos
memória do que armazenar um nucleotídio por byte, formando um bloco com
4 bases.
Cada sequencia é armazenada com um vetor de tamanho n, onde o número de
nucleotídios é menor que 4n. Dentro da estrutura de é armazenado o
tabanho do vetor e qual a posição de término do ultimo nucleotídio da
ultima posição do vetor.

\section{Busca de sobreposições}
A busca das sobreposições é realizada comparando bloco a bloco as
sequências. Ao invés de k-1 pares adjacentes, as sequencias são ligadas comparadando

\chapter{Resultados}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Modelo para escrever TCCs, dissertações e teses utilizando LaTeX, ABNTeX e BibTeX
% Autor/E-Mail: Robinson Alves Lemos/contato@robinson.mat.br/robinson.a.l@bol.com.br
% Data: 19/04/2008 
% Colaboradore(s)/E-Mail(s):
% Caso queira colaborar, entre em contato pelo e-mail e informe alterações que realizou.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

